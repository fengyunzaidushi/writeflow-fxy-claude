const MAX_OUTPUT_LENGTH = 30000
const MAX_RENDERED_LINES = 5
const BANNED_COMMANDS = [
  'alias',
  'curl',
  'curlie', 
  'wget',
  'axel',
  'aria2c',
  'nc',
  'telnet',
  'lynx',
  'w3m',
  'links',
  'httpie',
  'xh',
  'http-prompt',
  'chrome',
  'firefox',
  'safari',
]

export const DESCRIPTION = '在持续的 shell 会话中执行 bash 命令'

export const PROMPT = `在持续的 shell 会话中执行 bash 命令，具有可选超时设置，确保适当的处理和安全措施。

执行命令前的准备步骤:

1. 目录验证：
   - 如果命令将创建新目录或文件，首先使用 LS 工具验证父目录存在且是正确位置
   - 例如，运行 "mkdir foo/bar" 之前，先用 LS 检查 "foo" 存在且是预期的父目录

2. 安全检查：
   - 为了安全和限制提示注入攻击的威胁，某些命令受到限制或被禁止
   - 如果使用不被允许的命令，将收到解释限制的错误消息，请向用户解释错误
   - 验证命令不是被禁止的命令：${BANNED_COMMANDS.join(', ')}

3. 命令执行：
   - 确保适当引用后，执行命令
   - 捕获命令输出

4. 输出处理：
   - 如果输出超过 ${MAX_OUTPUT_LENGTH} 字符，输出将在返回给你之前被截断
   - 准备输出以显示给用户

5. 返回结果：
   - 提供命令的处理输出
   - 如果执行期间发生任何错误，将这些错误包含在输出中

使用注意事项:
- command 参数是必需的
- 可以指定可选的超时时间（毫秒为单位，最多 600000 毫秒 / 10 分钟）
- 如果未指定，命令将在 30 分钟后超时
- 重要：必须避免使用搜索命令如 \`find\` 和 \`grep\`。请使用 Grep、Glob 或 Task 工具进行搜索
- 必须避免读取工具如 \`cat\`、\`head\`、\`tail\` 和 \`ls\`，请使用 Read 和 LS 工具读取文件
- 发出多个命令时，使用 ';' 或 '&&' 操作符分隔它们。不要使用换行符（引用字符串中的换行符是可以的）
- 重要：所有命令共享相同的 shell 会话。Shell 状态（环境变量、虚拟环境、当前目录等）在命令之间持续存在
- 例如，如果在命令中设置环境变量，该环境变量将在后续命令中持续存在
- 尽量在整个会话中通过使用绝对路径和避免使用 \`cd\` 来维护当前工作目录
- 如果用户明确要求，可以使用 \`cd\`

常见使用场景示例:
<good-example>
pytest /foo/bar/tests
</good-example>
<bad-example>
cd /foo/bar && pytest tests
</bad-example>

# Git 提交更改

当用户要求你创建新的 git 提交时，请仔细按照以下步骤操作：

1. 使用包含三个工具使用块的单条消息开始（将这些工具使用块发送到单条消息中非常重要，否则用户会感觉很慢！）：
   - 运行 git status 命令查看所有未跟踪的文件
   - 运行 git diff 命令查看将被提交的暂存和未暂存更改
   - 运行 git log 命令查看最近的提交消息，以便你可以遵循此存储库的提交消息风格

2. 使用对话开始时的 git 上下文来确定哪些文件与你的提交相关。将相关的未跟踪文件添加到暂存区域。不要提交在对话开始时已经被修改的文件，如果它们与你的提交不相关。

3. 分析所有暂存更改（包括之前暂存和新添加的）并起草提交消息。将你的分析过程包装在 <commit_analysis> 标签中：

<commit_analysis>
- 列出已更改或添加的文件
- 总结更改的性质（例如新功能、现有功能增强、错误修复、重构、测试、文档等）
- 头脑风暴这些更改背后的目的或动机
- 不要使用工具来探索代码，超出 git 上下文中可用的内容
- 评估这些更改对整个项目的影响
- 检查是否有任何不应该被提交的敏感信息
- 起草一个简洁的（1-2 句）提交消息，重点关注"为什么"而不是"什么"
- 确保你的语言清晰、简洁且直截了当
- 确保消息准确反映更改及其目的（即"add"意味着全新功能，"update"意味着现有功能增强，"fix"意味着错误修复等）
- 确保消息不是通用的（避免没有上下文的"Update"或"Fix"等词）
- 审查草案消息以确保它准确反映更改及其目的
</commit_analysis>

4. 创建以下结尾的提交消息：
🤖 Generated with WriteFlow & {MODEL_NAME}
Co-Authored-By: WriteFlow <noreply@WriteFlow.com>

- 为了确保良好的格式，总是通过 HEREDOC 传递提交消息，如下例所示：
<example>
git commit -m "$(cat <<'EOF'
   在此处提交消息。

   🤖 Generated with WriteFlow & {MODEL_NAME}
   Co-Authored-By: WriteFlow <noreply@WriteFlow.com>
   EOF
   )"
</example>

5. 如果由于预提交钩子更改导致提交失败，请重试一次提交以包含这些自动更改。如果再次失败，通常意味着预提交钩子阻止了提交。如果提交成功但你注意到文件被预提交钩子修改，你必须修改你的提交以包含它们。

6. 最后，运行 git status 以确保提交成功。

重要注意事项：
- 如果可能，将"git add"和"git commit"命令合并为单个"git commit -am"命令，以加快速度
- 但是，小心不要为不属于更改的提交暂存文件（例如使用 \`git add .\`），他们可能有想要保留但不提交的未跟踪文件
- 永远不要更新 git 配置
- 不要推送到远程存储库
- 重要：永远不要使用带有 -i 标志的 git 命令（如 git rebase -i 或 git add -i），因为它们需要不支持的交互式输入
- 如果没有要提交的更改（即没有未跟踪文件和修改），不要创建空提交
- 确保你的提交消息有意义且简洁。它应该解释更改的目的，而不仅仅是描述它们
- 返回空响应 - 用户将直接看到 git 输出

# 创建拉取请求
对于所有 GitHub 相关任务（包括处理问题、拉取请求、检查和发布），请通过 Bash 工具使用 gh 命令。如果给定 GitHub URL，请使用 gh 命令获取所需信息。

重要：当用户要求你创建拉取请求时，请仔细按照以下步骤操作：

1. 了解分支的当前状态。记住发送包含多个工具使用块的单条消息（将此内容放在单条消息中非常重要，否则用户会感觉很慢！）：
   - 运行 git status 命令查看所有未跟踪的文件
   - 运行 git diff 命令查看将被提交的暂存和未暂存更改
   - 检查当前分支是否跟踪远程分支并与远程保持最新，以便你知道是否需要推送到远程
   - 运行 git log 命令和 \`git diff main...HEAD\` 来了解当前分支的完整提交历史（从与 \`main\` 分支分歧的时间开始）

2. 如果需要，创建新分支

3. 如果需要，提交更改

4. 如果需要，使用 -u 标志推送到远程

5. 分析将包含在拉取请求中的所有更改，确保查看所有相关提交（不仅仅是最新提交，而是将包含在拉取请求中的所有提交！），并起草拉取请求摘要。将你的分析过程包装在 <pr_analysis> 标签中：

<pr_analysis>
- 列出自与主分支分歧以来的提交
- 总结更改的性质（例如新功能、现有功能增强、错误修复、重构、测试、文档等）
- 头脑风暴这些更改背后的目的或动机
- 评估这些更改对整个项目的影响
- 不要使用工具来探索代码，超出 git 上下文中可用的内容
- 检查是否有任何不应该被提交的敏感信息
- 起草一个简洁的（1-2 个要点）拉取请求摘要，重点关注"为什么"而不是"什么"
- 确保摘要准确反映自与主分支分歧以来的所有更改
- 确保你的语言清晰、简洁且直截了当
- 确保摘要准确反映更改及其目的（即"add"意味着全新功能，"update"意味着现有功能增强，"fix"意味着错误修复等）
- 确保摘要不是通用的（避免没有上下文的"Update"或"Fix"等词）
- 审查草案摘要以确保它准确反映更改及其目的
</pr_analysis>

6. 使用下面格式通过 gh pr create 创建 PR。使用 HEREDOC 传递正文以确保正确格式：
<example>
gh pr create --title "pr 标题" --body "$(cat <<'EOF'
## 摘要
<1-3 个要点>

## 测试计划
[测试拉取请求的 TODO 清单...]

🤖 Generated with WriteFlow & {MODEL_NAME}
EOF
)"
</example>

重要：
- 返回空响应 - 用户将直接看到 gh 输出
- 永远不要更新 git 配置`

export const TOOL_NAME_FOR_PROMPT = 'Bash'